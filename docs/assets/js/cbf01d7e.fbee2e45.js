"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6209],{78048:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=n(87462),i=(n(67294),n(3905));n(78561);const r={},a="Monitoring",s={unversionedId:"hosting/monitoring",id:"hosting/monitoring",title:"Monitoring",description:"Uptime monitoring",source:"@site/contents/76-hosting/80-monitoring.md",sourceDirName:"76-hosting",slug:"/hosting/monitoring",permalink:"/hosting/monitoring",draft:!1,editUrl:"https://github.com/nboldhq/docs/tree/main/contents/76-hosting/80-monitoring.md",tags:[],version:"current",sidebarPosition:80,frontMatter:{},sidebar:"autoSidebar",previous:{title:"Updates Management",permalink:"/hosting/updating"},next:{title:"References",permalink:"/hosting/references/"}},l={},p=[{value:"Uptime monitoring",id:"uptime-monitoring",level:2},{value:"Monika",id:"monika",level:3},{value:"Azure Front Door",id:"azure-front-door",level:3},{value:"Logging",id:"logging",level:2},{value:"Application Performance Monitoring (APM)",id:"application-performance-monitoring-apm",level:2},{value:"Collecting metrics",id:"collecting-metrics",level:2},{value:"Metrics collector",id:"metrics-collector",level:3},{value:"Collect application metrics",id:"collect-application-metrics",level:3},{value:"Collect Redis cache metrics",id:"collect-redis-cache-metrics",level:3},{value:"Collect Redis queues metrics",id:"collect-redis-queues-metrics",level:3},{value:"Collect uptime metrics",id:"collect-uptime-metrics",level:3},{value:"Auditing",id:"auditing",level:2}],m={toc:p};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"monitoring"},"Monitoring"),(0,i.kt)("h2",{id:"uptime-monitoring"},"Uptime monitoring"),(0,i.kt)("p",null,"To monitor their uptime, each container exposes an HTTP endpoint at ",(0,i.kt)("inlineCode",{parentName:"p"},"/monitoring/ping"),", that answers to ",(0,i.kt)("inlineCode",{parentName:"p"},"HEAD")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"GET")," requests with a ",(0,i.kt)("inlineCode",{parentName:"p"},"200")," empty response."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"user-agent")," HTTP header to identify the monitoring service sending the requests.")),(0,i.kt)("p",null,"As of today, here are the uptime monitors we're supporting:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Monika"),(0,i.kt)("li",{parentName:"ul"},"Azure Front Door")),(0,i.kt)("h3",{id:"monika"},"Monika"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://monika.hyperjump.tech"},"Monika")," is the default option when running your own nBold platform using our sample Docker deployment project."),(0,i.kt)("p",null,"A sample basic configuration file for monitoring the uptime and latency of the application containers would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"probes:\n  - id: api_probe\n    name: API ping monitoring endpoint\n    description: Monitors the /monitoring/ping endpoint of the nBold api service\n    interval: 10\n    requests:\n      - method: HEAD\n        url: 'http://salestim_api:3000/monitoring/ping'\n        timeout: 7000\n        alerts:\n          - query: response.status != 200\n            message: \"\ud83d\udd25 API Service is DOWN. Expected 200 but returned {{ response.status }}.\"\n    incidentThreshold: 1\n    recoveryThreshold: 3\n  - id: web_probe\n    name: Web ping monitoring endpoint\n    description: Monitors the /monitoring/ping endpoint of the nBold web service\n    interval: 10\n    requests:\n      - method: HEAD\n        url: 'http://salestim_web:3000/monitoring/ping'\n        timeout: 7000\n        alerts:\n          - query: response.status != 200\n            message: \"\ud83d\udd25 WEB Service is DOWN. Expected 200 but returned {{ response.status }}.\"\n    incidentThreshold: 1\n    recoveryThreshold: 3\n  - id: jobs_probe\n    name: JOBS ping monitoring endpoint\n    description: Monitors the /monitoring/ping endpoint of the nBold jobs service\n    interval: 10\n    requests:\n      - method: HEAD\n        url: 'http://salestim_jobs:3000/monitoring/ping'\n        timeout: 7000\n        alerts:\n          - query: response.status != 200\n            message: \"\ud83d\udd25 JOBS Service is DOWN. Expected 200 but returned {{ response.status }}.\"\n    incidentThreshold: 1\n    recoveryThreshold: 3\n  - id: scheduler_probe\n    name: SCHEDULER ping monitoring endpoint\n    description: Monitors the /monitoring/ping endpoint of the nBold scheduler service\n    interval: 10\n    requests:\n      - method: HEAD\n        url: 'http://salestim_scheduler:3000/monitoring/ping'\n        timeout: 7000\n        alerts:\n          - query: response.status != 200\n            message: \"\ud83d\udd25 SCHEDULER Service is DOWN. Expected 200 but returned {{ response.status }}.\"\n    incidentThreshold: 1\n    recoveryThreshold: 3\nnotifications:\n  - id: webhook_notification\n    type: webhook\n    data:\n      url: 'https://YOUR_WEBHOOK_URL'\n  - id: teams_notification\n    type: teams\n    data:\n      url: 'https://YOUR_TEAMS_WEBHOOK_URL'\n")),(0,i.kt)("p",null,"To tailor this example, you can refer to Monika's ",(0,i.kt)("a",{parentName:"p",href:"https://monika.hyperjump.tech/overview"},"configuration")," documentation."),(0,i.kt)("h3",{id:"azure-front-door"},"Azure Front Door"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/frontdoor/"},"Azure Front Door")," comes with health probes that are used to perform load-balancing and achieve failover in case of a container malfunction. Keep in mind that strictly speaking, ",(0,i.kt)("strong",{parentName:"p"},"Azure Front Door is not an uptime monitoring app"),"."),(0,i.kt)("p",null,"To see a detailed Azure Front Door configuration, see our ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/azure-resources-reference.md"},"Azure resources reference")," documentation."),(0,i.kt)("p",null,"You can also refer to the Azure Front Door ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/frontdoor/front-door-health-probes"},"Health probes")," documentation."),(0,i.kt)("admonition",{title:"Warning",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Since Azure Front Door has many edge environments globally, health probe volume for your backends can be quite high, ranging from 25 requests every minute to ",(0,i.kt)("strong",{parentName:"p"},"as high as 1200 requests per minute"),", depending on the configured probe frequency."),(0,i.kt)("p",{parentName:"admonition"},"For instance, with the default probe frequency of 30 seconds, the requests volume on your backend would be about ",(0,i.kt)("strong",{parentName:"p"},"200 requests per minute"),".")),(0,i.kt)("h2",{id:"logging"},"Logging"),(0,i.kt)("p",null,"Our platform comes with a configurable logging module that generates logs as configured by the ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/configuration-reference.md"},"Logging configuration"),"."),(0,i.kt)("admonition",{title:"Persisting log files",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Log files persistence is not enabled by default and we recommend to use an external log ingestion solution in production environments.")),(0,i.kt)("p",null,"As nBold comes with a native connector for Microsoft Application Insights, the easiest and recommended way to collect and centralize all the logs and traces, is to enable and configure the connector from the ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/configuration-reference.md"},"Application Insights configuration"),"."),(0,i.kt)("p",null,"Application Insights is part of the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/azure-monitor/overview"},"Azure Monitor")," service and uses an Azure Log Analytics Workspace under the hood as a storage. From Application Insights, you can live-monitor the whole nBold platform, investigate issues using traces and events, detect performance bottlenecks... Learn more about ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview"},"Microsoft Application Insights"),"."),(0,i.kt)("h2",{id:"application-performance-monitoring-apm"},"Application Performance Monitoring (APM)"),(0,i.kt)("p",null,"As nBold comes with a native connector for Microsoft Application Insights, the easiest and recommended way to collect and centralize APM metrics, is to enable and configure the connector from the ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/configuration-reference.md"},"Application Insights configuration"),"."),(0,i.kt)("p",null,"Application Insights is part of the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/azure-monitor/overview"},"Azure Monitor")," service and uses an Azure Log Analytics Workspace under the hood as a storage. From Application Insights, you can live-monitor the whole nBold platform, investigate issues using traces and events, detect performance bottlenecks... Learn more about ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview"},"Microsoft Application Insights"),"."),(0,i.kt)("h2",{id:"collecting-metrics"},"Collecting metrics"),(0,i.kt)("h3",{id:"metrics-collector"},"Metrics collector"),(0,i.kt)("p",null,"The nBold platform relies on ",(0,i.kt)("a",{parentName:"p",href:"https://prometheus.io/"},"Prometheus")," to collect and centralize all its metrics."),(0,i.kt)("p",null,"Prometheus is an open-source software application that is used for event monitoring. It collects metrics such as requests count, duration and exceptions from applications and records them in a time-series database. Prometheus is also used for monitoring CPU status and memory/disk-space usage so it can be used and be represented in a meaningful display."),(0,i.kt)("p",null,"Prometheus has become widely known and used in software industries due to its open-source and ease of use. Prometheus is a stand alone and self containing application that run by pulling data from services using worker systems that runs periodically."),(0,i.kt)("h3",{id:"collect-application-metrics"},"Collect application metrics"),(0,i.kt)("p",null,"To expose their metrics, each SalesTIm container exposes an HTTP endpoint at ",(0,i.kt)("inlineCode",{parentName:"p"},"/monitoring/metrics"),", that answers to ",(0,i.kt)("inlineCode",{parentName:"p"},"GET")," requests with a ",(0,i.kt)("inlineCode",{parentName:"p"},"200")," response, using the ",(0,i.kt)("a",{parentName:"p",href:"https://prometheus.io/"},"Prometheus")," exporter format."),(0,i.kt)("p",null,"Exported metrics could be configured from the ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/configuration-reference.md"},"Prometheus Configuration")," options."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Metrics exposed:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Default metrics from ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/siimon/prom-client"},"prom-client"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"http_requests_total"),": Counter for total requests received, has labels ",(0,i.kt)("inlineCode",{parentName:"li"},"route"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"method"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"status")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"http_request_duration_seconds"),": - Duration of HTTP requests in seconds, has labels ",(0,i.kt)("inlineCode",{parentName:"li"},"route"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"method"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"status"))),(0,i.kt)("admonition",{title:"Notes",type:"tip"},(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},"Standard nodejs exposed metrics are prefixed by ",(0,i.kt)("inlineCode",{parentName:"li"},"st_")),(0,i.kt)("li",{parentName:"ol"},"The labels ",(0,i.kt)("inlineCode",{parentName:"li"},"route")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"status")," are normalized:")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"route"),": will normalize id like route params"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"status"),": will normalize to status code family groups, like ",(0,i.kt)("inlineCode",{parentName:"li"},"2XX")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"4XX"),"."))),(0,i.kt)("admonition",{title:"How to secure the metrics endpoint?",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"In production, you can secure the ",(0,i.kt)("inlineCode",{parentName:"p"},"/monitoring/metrics")," endpoint to prevent any technical information leak. To do so, define the ",(0,i.kt)("inlineCode",{parentName:"p"},"PROMETHEUS_EXPORTER_AUTH_TOKEN")," property from the ",(0,i.kt)("a",{parentName:"p",href:"/hosting/references/configuration-reference.md"},"Prometheus Configuration")," options.  ")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"A convenient way to generate a secure token is to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"openssl")," command, such as:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'# The rand command encodes the produced random bytes in base64. This encoding converts bytes to alphanumeric characters, including the characters `=`, `+`, and `/`. These characters are filtered to have passwords without special characters and prevent url encoding issues. It reduces the random character of the token a little bit, but is not a concern when the token is more than 10 characters.\nopenssl rand -base64 29 | tr -d "=+/" | cut -c1-25\n'))),(0,i.kt)("h3",{id:"collect-redis-cache-metrics"},"Collect Redis cache metrics"),(0,i.kt)("p",null,"Redis metrics can be exported by using a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/oliver006/redis_exporter"},"Redis Prometheus exporter")," container.\nMost items from the ",(0,i.kt)("inlineCode",{parentName:"p"},"INFO")," command are exported, see ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/commands/info"},"Redis INFO command documentation")," for details."),(0,i.kt)("h3",{id:"collect-redis-queues-metrics"},"Collect Redis queues metrics"),(0,i.kt)("p",null,"nBold uses the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/OptimalBits/bull"},"Bull")," module to manage its asynchronous jobs. Bull is a Queue package for handling distributed jobs and messages in NodeJS."),(0,i.kt)("p",null,"To monitor Bull queues, you can use a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/UpHabit/bull_exporter"},"Bull Prometheus exporter")," container.\nMost items from the ",(0,i.kt)("inlineCode",{parentName:"p"},"INFO")," command are exported, see ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/commands/info"},"Redis INFO command documentation")," for details."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Metrics exposed:"),"\n| Metric                       | type    | description |\n|------------------------------|---------|-------------|\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_completed"),"         | counter | Total number of completed jobs                          |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_complete_duration")," | summary | Processing time for completed jobs                      |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_active"),"            | counter | Total number of active jobs (currently being processed) |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_delayed"),"           | counter | Total number of jobs that will run in the future        |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_failed"),"            | counter | Total number of failed jobs                             |\n| ",(0,i.kt)("inlineCode",{parentName:"p"},"bull_queue_waiting"),"           | counter | Total number of jobs waiting to be processed            |"),(0,i.kt)("h3",{id:"collect-uptime-metrics"},"Collect uptime metrics"),(0,i.kt)("p",null,"If you're using Monika to monitor your platform uptime, you can customize its container configuration to make it expose some useful metrics."),(0,i.kt)("p",null,"To do so, you must customize Monika's container startup command to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"--prometheus"),", such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},'# Run Monika in the background and expose its Prometheus metrics to the 3010 port.\ncommand = ["monika", "-c", "/config/monika.yml", "--prometheus", "3010"]\n')),(0,i.kt)("p",null,"Of course, you can also use this technique to expose metrics from any Prometheus-compatible uptime monitoring solution."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Metrics exposed:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Default metrics from ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/siimon/prom-client"},"prom-client")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"monika_request_status_code_info"),": (gauge) HTTP status code"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"monika_request_response_time_seconds"),": (histogram) Duration of probe request in seconds"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"monika_request_response_size_bytes"),": (gauge) Size of response size in bytes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"monika_probes_total"),": (gauge) Total of all probe")),(0,i.kt)("h2",{id:"auditing"},"Auditing"),(0,i.kt)("p",null,"To see the list au audited events, you can refer to the ",(0,i.kt)("a",{parentName:"p",href:"./references/events-reference"},"Events reference")," documentation, and look for events with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Tracking")," configuration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Enabled: ",(0,i.kt)("inlineCode",{parentName:"li"},"true")),(0,i.kt)("li",{parentName:"ul"},"Audit trail: ",(0,i.kt)("inlineCode",{parentName:"li"},"true"))),(0,i.kt)("admonition",{title:"Exporting audit trails from the audit database",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Our ",(0,i.kt)("a",{parentName:"p",href:"./references/events-reference"},"Events reference")," documentation also specifies the mapping between an audited event and its representation in the audit database:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"Table: Tracking ",(0,i.kt)("inlineCode",{parentName:"li"},"Code")),(0,i.kt)("li",{parentName:"ul"},"Columns: Tracking ",(0,i.kt)("inlineCode",{parentName:"li"},"Audited fields")," "))))}u.isMDXComponent=!0}}]);